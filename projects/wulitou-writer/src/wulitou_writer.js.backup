#!/usr/bin/env node

const fs = require('fs').promises;
const path = require('path');

class WulitouWriter {
    constructor() {
        this.projectRoot = __dirname + '/..';
        this.characterProfile = null;
        this.styleGuide = null;
        this.loadConfigurations();
    }

    async loadConfigurations() {
        try {
            // è¼‰å…¥è§’è‰²è¨­å®š
            const characterData = await fs.readFile(
                path.join(this.projectRoot, 'config/character_profile.json'),
                'utf8'
            );
            this.characterProfile = JSON.parse(characterData);

            // è¼‰å…¥å¯«ä½œé¢¨æ ¼æŒ‡å—
            this.styleGuide = await fs.readFile(
                path.join(this.projectRoot, 'config/writing_style_guide.md'),
                'utf8'
            );
        } catch (error) {
            console.error('è¼‰å…¥é…ç½®æ–‡ä»¶æ™‚ç™¼ç”ŸéŒ¯èª¤:', error.message);
        }
    }

    generatePrompt(inputData) {
        const character = this.characterProfile.character;
        const { ä¸»é¡Œ, æ–‡å­—é‡, å¹´é½¡é™åˆ¶, æ–‡ç« é¡å‹, èªèª¿é¢¨æ ¼, æ‘˜è¦å‚™è¨», ç‰¹æ®Šè¦æ±‚ } = inputData.writing_request;

        const prompt = `
ä½ ç¾åœ¨æ˜¯"ç„¡ä¿šé ­"ï¼Œä¸€ä½ç”Ÿæ–¼1968å¹´çš„å°ç£è³‡æ·±å¯«æ‰‹ã€‚

## ä½ çš„èƒŒæ™¯ç‰¹è‰²ï¼š
- å‡ºç”Ÿå¹´ä»½ï¼š1968å¹´ï¼Œç¾å¹´56æ­²
- ç¶“æ­·äº†å°ç£å¾å¨æ¬Šæ™‚ä»£åˆ°æ°‘ä¸»åŒ–ï¼Œå¾è¾²æ¥­ç¤¾æœƒåˆ°è³‡è¨Šæ™‚ä»£çš„å®Œæ•´è½‰è®Š
- å¯«ä½œé¢¨æ ¼ï¼š${èªèª¿é¢¨æ ¼}ã€å¹½é»˜è¼•é¬†ã€çŸ¥è­˜æ€§ä½†ä¸èªªæ•™
- æ“…é•·é ˜åŸŸï¼š${character.knowledge_domains.join('ã€')}

## ä½ çš„äººç”Ÿç¶“æ­·é‡é»ï¼š
### ç«¥å¹´æ™‚æœŸ (1970å¹´ä»£)ï¼š
- æ”¿æ²»ç’°å¢ƒï¼šæˆ’åš´æ™‚æœŸã€å¨æ¬Šçµ±æ²»
- ç”Ÿæ´»æ–¹å¼ï¼šå¤§å®¶åº­åˆ¶åº¦ã€ä¸‰åˆé™¢ã€é»‘ç™½é›»è¦–ã€æ‰‹å¯«ä¿¡ä»¶
- äº¤é€šå·¥å…·ï¼šè…³è¸è»Šã€å…¬è»Šç‚ºä¸»
- å¨›æ¨‚ï¼šå¸ƒè¢‹æˆ²ã€æ­Œä»”æˆ²ã€æ¼«ç•«æ›¸

### é’å¹´æ™‚æœŸ (1980å¹´ä»£)ï¼š
- æ”¿æ²»ç’°å¢ƒï¼šè§£åš´å‰å¤•ã€æ°‘ä¸»åŒ–èŒèŠ½
- ç§‘æŠ€ç™¼å±•ï¼šå½©è‰²é›»è¦–ã€å¡å¸¶éŒ„éŸ³æ©Ÿã€æ—©æœŸé›»è…¦
- æ–‡åŒ–ï¼šKTVèˆˆèµ·ã€æµè¡ŒéŸ³æ¨‚é»ƒé‡‘æ™‚ä»£

### æˆå¹´æ™‚æœŸ (1990-2000å¹´ä»£)ï¼š
- æ”¿æ²»ï¼šæ°‘ä¸»åŒ–å®Œæˆã€æ”¿é»¨è¼ªæ›¿
- ç§‘æŠ€ï¼šå€‹äººé›»è…¦ã€æ‰‹æ©Ÿã€ç¶²éš›ç¶²è·¯æ™®åŠ
- ç¤¾æœƒï¼šç¶“æ¿Ÿèµ·é£›ã€æ¶ˆè²»ä¸»ç¾©ã€å°‘å­åŒ–

### ç¾åœ¨ (2020å¹´ä»£)ï¼š
- ç§‘æŠ€ï¼šAIæ™‚ä»£ã€æ™ºæ…§å‹æ‰‹æ©Ÿã€ç¤¾ç¾¤åª’é«”
- ç¤¾æœƒï¼šæ•¸ä½åŒ–ç”Ÿæ´»ã€é è·å·¥ä½œã€æ°¸çºŒæ„è­˜

## å¯«ä½œä»»å‹™ï¼š
ä¸»é¡Œï¼š${ä¸»é¡Œ}
æ–‡å­—é‡ï¼š${æ–‡å­—é‡.é¸æ“‡}
å¹´é½¡é™åˆ¶ï¼š${å¹´é½¡é™åˆ¶.é¸æ“‡}
æ–‡ç« é¡å‹ï¼š${æ–‡ç« é¡å‹.é¸æ“‡}
èªèª¿é¢¨æ ¼ï¼š${èªèª¿é¢¨æ ¼}
æ‘˜è¦å‚™è¨»ï¼š${æ‘˜è¦å‚™è¨»}
ç‰¹æ®Šè¦æ±‚ï¼š${ç‰¹æ®Šè¦æ±‚}

## å¯«ä½œè¦æ±‚ï¼š
1. ä»¥ç¬¬ä¸€äººç¨±"æˆ‘"ä¾†å¯«ä½œï¼Œé«”ç¾ç„¡ä¿šé ­çš„å€‹äººç¶“æ­·å’Œè§€é»
2. å–„ç”¨"æƒ³ç•¶å¹´vsç¾åœ¨"çš„å°æ¯”æ‰‹æ³•
3. åœ¨è¼•é¬†å¹½é»˜ä¸­èå…¥çŸ¥è­˜æ€§å…§å®¹
4. ä½¿ç”¨å°ç£æœ¬åœŸçš„èªè¨€è¡¨é”å’Œæ–‡åŒ–å…§å®¹
5. æ–‡ç« çµæ§‹è¦æœ‰å¸ç›é–‹å ´ã€æ•…äº‹å±•é–‹ã€æ·±åº¦æ€è€ƒã€å¹½é»˜æ”¶å°¾
6. é©åº¦ä½¿ç”¨ç„¡ä¿šé ­çš„æ‹›ç‰Œèªå¥ï¼š${character.signature_phrases.join('ã€')}

## å…§å®¹é™åˆ¶ï¼š
- å¹´é½¡é™åˆ¶ï¼š${å¹´é½¡é™åˆ¶.é¸æ“‡} ${å¹´é½¡é™åˆ¶.ç‰¹æ®Šèªªæ˜ ? '(' + å¹´é½¡é™åˆ¶.ç‰¹æ®Šèªªæ˜ + ')' : ''}
- é¿å…éåº¦æ”¿æ²»åŒ–æˆ–çˆ­è­°æ€§å…§å®¹
- ä¿æŒæ­£é¢ç©æ¥µçš„åƒ¹å€¼è§€
- å°Šé‡ä¸åŒä¸–ä»£å’Œæ–‡åŒ–

è«‹æ ¹æ“šä»¥ä¸Šè¨­å®šï¼Œå¯«å‡ºä¸€ç¯‡ç¬¦åˆè¦æ±‚çš„æ–‡ç« ã€‚æ–‡ç« è¦é«”ç¾ç„¡ä¿šé ­è±å¯Œçš„äººç”Ÿé–±æ­·ï¼Œä»¥åŠå°å°ç£ç¤¾æœƒè®Šé·çš„æ·±åº¦è§€å¯Ÿã€‚
`;

        return prompt;
    }

    async createWritingTemplate(inputData) {
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const fileName = `writing_request_${timestamp}.json`;
        const filePath = path.join(this.projectRoot, 'templates', fileName);

        // æ·»åŠ æ™‚é–“æˆ³è¨˜
        inputData.metadata.å‰µå»ºæ™‚é–“ = new Date().toLocaleString('zh-TW');

        await fs.writeFile(filePath, JSON.stringify(inputData, null, 2), 'utf8');
        return { fileName, filePath };
    }

    async generateArticle(inputData) {
        const prompt = this.generatePrompt(inputData);
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');

        // ä¿å­˜ç”Ÿæˆæç¤º
        const promptFileName = `prompt_${timestamp}.txt`;
        const promptPath = path.join(this.projectRoot, 'output', promptFileName);
        await fs.writeFile(promptPath, prompt, 'utf8');

        // å‰µå»ºè¼¸å‡ºæ–‡ä»¶æ¨¡æ¿
        const outputTemplate = {
            metadata: {
                ä¸»é¡Œ: inputData.writing_request.ä¸»é¡Œ,
                å‰µå»ºæ™‚é–“: new Date().toLocaleString('zh-TW'),
                ä½œè€…: 'ç„¡ä¿šé ­',
                æ–‡å­—é‡: inputData.writing_request.æ–‡å­—é‡.é¸æ“‡,
                å¹´é½¡é™åˆ¶: inputData.writing_request.å¹´é½¡é™åˆ¶.é¸æ“‡,
                æ–‡ç« é¡å‹: inputData.writing_request.æ–‡ç« é¡å‹.é¸æ“‡,
                èªèª¿é¢¨æ ¼: inputData.writing_request.èªèª¿é¢¨æ ¼
            },
            prompt: prompt,
            generated_article: "è«‹å°‡æ­¤æç¤ºè¤‡è£½åˆ°AIåŠ©æ‰‹(å¦‚Claudeã€ChatGPT)ä¸­ç”Ÿæˆæ–‡ç« ï¼Œç„¶å¾Œå°‡çµæœè²¼å›é€™è£¡",
            notes: inputData.writing_request.æ‘˜è¦å‚™è¨»
        };

        const outputFileName = `article_${timestamp}.json`;
        const outputPath = path.join(this.projectRoot, 'output', outputFileName);
        await fs.writeFile(outputPath, JSON.stringify(outputTemplate, null, 2), 'utf8');

        return {
            promptPath,
            outputPath,
            prompt
        };
    }

    async createUserInterface() {
        const template = await fs.readFile(
            path.join(this.projectRoot, 'templates/input_template.json'),
            'utf8'
        );

        const userInterfaceFile = path.join(this.projectRoot, 'user_input.json');
        await fs.writeFile(userInterfaceFile, template, 'utf8');

        console.log(`\nğŸ“ ç„¡ä¿šé ­å¯«æ‰‹ç³»çµ±å·²å°±ç·’ï¼\n`);
        console.log(`è«‹ç·¨è¼¯ä»¥ä¸‹æ–‡ä»¶ä¾†è¼¸å…¥æ‚¨çš„å¯«ä½œéœ€æ±‚ï¼š`);
        console.log(`æ–‡ä»¶è·¯å¾‘: ${userInterfaceFile}\n`);
        console.log(`ç·¨è¼¯å®Œæˆå¾Œï¼Œé‹è¡Œä»¥ä¸‹å‘½ä»¤ç”Ÿæˆæ–‡ç« ï¼š`);
        console.log(`node src/wulitou_writer.js generate\n`);

        return userInterfaceFile;
    }
}

// ä¸»ç¨‹å¼é‚è¼¯
async function main() {
    const writer = new WulitouWriter();
    const command = process.argv[2];

    if (command === 'generate') {
        try {
            const userInputPath = path.join(writer.projectRoot, 'user_input.json');
            const inputData = JSON.parse(await fs.readFile(userInputPath, 'utf8'));

            // é©—è­‰å¿…è¦æ¬„ä½
            if (!inputData.writing_request.ä¸»é¡Œ) {
                console.error('âŒ éŒ¯èª¤ï¼šè«‹å¡«å…¥ä¸»é¡Œ');
                return;
            }
            if (!inputData.writing_request.æ–‡å­—é‡.é¸æ“‡) {
                console.error('âŒ éŒ¯èª¤ï¼šè«‹é¸æ“‡æ–‡å­—é‡');
                return;
            }
            if (!inputData.writing_request.æ–‡ç« é¡å‹.é¸æ“‡) {
                console.error('âŒ éŒ¯èª¤ï¼šè«‹é¸æ“‡æ–‡ç« é¡å‹');
                return;
            }

            const result = await writer.generateArticle(inputData);

            console.log('\nâœ… æ–‡ç« ç”Ÿæˆæç¤ºå·²å‰µå»ºï¼');
            console.log(`\nğŸ“‹ æç¤ºæ–‡ä»¶: ${result.promptPath}`);
            console.log(`ğŸ“„ è¼¸å‡ºæ¨¡æ¿: ${result.outputPath}`);
            console.log(`\nğŸ¤– è«‹è¤‡è£½ä»¥ä¸‹æç¤ºåˆ°AIåŠ©æ‰‹ä¸­ç”Ÿæˆæ–‡ç« ï¼š\n`);
            console.log('='.repeat(80));
            console.log(result.prompt);
            console.log('='.repeat(80));

        } catch (error) {
            console.error('âŒ ç”Ÿæˆæ–‡ç« æ™‚ç™¼ç”ŸéŒ¯èª¤:', error.message);
        }
    } else {
        await writer.createUserInterface();
    }
}

if (require.main === module) {
    main().catch(console.error);
}

module.exports = WulitouWriter;